
<html>
<head>
    <meta charset="UTF-8">
    <title>Time Series Evidence Report</title>
</head>
<body>
    <h1>Time Series Evidence Report</h1>
    <pre style="background-color:#f4f4f4; padding:15px;"># -*- coding: utf-8 -*-
"""evidenciaSeriesdeTiempo

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1duqmkQx55veDGnomPeFfkmFVpaA2j7sO
"""

# ============================
# FINAL CODE - TIME SERIES MODELING (AR, ARMA, ARIMA + Forecast + Stationarity + Cointegration + Forecast Print)
# Author: Alejandro
# ============================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, kpss, coint
from statsmodels.tsa.ar_model import AutoReg
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen
from itertools import combinations
from google.colab import files
import io, warnings
warnings.filterwarnings("ignore")

# STEP 1: Upload Files
assets = ['JPM', 'JNJ', 'PG']
data = {}

for asset in assets:
    print(f"\nüîº Upload {asset}.xlsx (must include '1min' and '5min' sheets):")
    uploaded = files.upload()
    filename = list(uploaded.keys())[0]
    xls = pd.ExcelFile(io.BytesIO(uploaded[filename]))

    df_1min = pd.read_excel(xls, sheet_name='1min')
    df_5min = pd.read_excel(xls, sheet_name='5min')
    df_1min = df_1min.rename(columns=lambda x: x.strip())
    df_5min = df_5min.rename(columns=lambda x: x.strip())

    data[asset] = {
        '1min': df_1min['Close'].dropna().reset_index(drop=True),
        '5min': df_5min['Close'].dropna().reset_index(drop=True)
    }

# STEP 2: Stationarity Tests
def run_stationarity_tests(series, name="Series"):
    print(f"\nüìå Stationarity Tests - {name}")
    adf_result = adfuller(series)
    kpss_result, kpss_p, _, _ = kpss(series, regression='c', nlags="auto")
    print(f"ADF Statistic = {adf_result[0]:.4f}, p-value = {adf_result[1]:.4f}")
    print("‚Üí ADF:", "Rejects H0 (stationary)" if adf_result[1] < 0.05 else "Fails to reject H0 (non-stationary)")
    print(f"KPSS Statistic = {kpss_result:.4f}, p-value = {kpss_p:.4f}")
    print("‚Üí KPSS:", "Rejects H0 (non-stationary)" if kpss_p < 0.05 else "Fails to reject H0 (stationary)")

# STEP 3: Modeling and Forecasting (with printed predictions)
def model_and_forecast(series, name="Series"):
    print(f"\n============================")
    print(f"üìà Modeling for {name}")
    print(f"============================")

    # AR Model
    ar_model = AutoReg(series, lags=5).fit()
    ar_pred = ar_model.predict(start=len(series), end=len(series)+9)
    print(f"\nüî∏ AR Forecast - {name}: {np.round(ar_pred.values, 2)}")

    plt.figure(figsize=(10,4))
    plt.plot(series[-50:], label='Historical')
    plt.plot(range(len(series), len(series)+10), ar_pred, label='AR Forecast')
    plt.title(f'AR Forecast - {name}')
    plt.legend(); plt.grid(True); plt.show()

    # ARMA Model
    arma_model = ARIMA(series, order=(2,0,1)).fit()
    arma_pred = arma_model.forecast(steps=10)
    print(f"\nüî∏ ARMA Forecast - {name}: {np.round(arma_pred.values, 2)}")

    plt.figure(figsize=(10,4))
    plt.plot(series[-50:], label='Historical')
    plt.plot(range(len(series), len(series)+10), arma_pred, label='ARMA Forecast')
    plt.title(f'ARMA Forecast - {name}')
    plt.legend(); plt.grid(True); plt.show()

    # ARIMA Model
    arima_model = ARIMA(series, order=(2,1,1)).fit()
    arima_pred = arima_model.forecast(steps=10)
    print(f"\nüî∏ ARIMA Forecast - {name}: {np.round(arima_pred.values, 2)}")

    plt.figure(figsize=(10,4))
    plt.plot(series[-50:], label='Historical')
    plt.plot(range(len(series), len(series)+10), arima_pred, label='ARIMA Forecast')
    plt.title(f'ARIMA Forecast - {name}')
    plt.legend(); plt.grid(True); plt.show()

# STEP 4: Run All (1min and 5min)
for asset in data:
    for interval in ['1min', '5min']:
        ts = data[asset][interval]
        run_stationarity_tests(ts, f"{asset} - {interval}")
        model_and_forecast(ts, f"{asset} - {interval}")

# STEP 5: Johansen Cointegration
def preprocess_for_cointegration(series_dict):
    transformed = {}
    for name, s in series_dict.items():
        s = s[s > 0]
        logged = np.log(s)
        differenced = logged.diff().dropna()
        transformed[name] = differenced.reset_index(drop=True)
    return pd.DataFrame(transformed)

def run_johansen_cointegration(data_dict):
    print("\nüìâ Johansen Cointegration Test:")

    def try_test(df, label):
        try:
            result = coint_johansen(df, det_order=0, k_ar_diff=1)
            print(f"‚úÖ Johansen test successful for {label}")
            print("Eigenvalues:", result.eig)
            return True
        except Exception as e:
            print(f"‚ùå Failed for {label}: {str(e)}")
            return False

    df_all = pd.concat([
        data_dict['JPM']['5min'],
        data_dict['JNJ']['5min'],
        data_dict['PG']['5min']
    ], axis=1)
    df_all.columns = ['JPM', 'JNJ', 'PG']

    if try_test(df_all, "JPM, JNJ, PG"):
        return

    print("\nüîÅ Trying pairwise combinations...")
    for combo in combinations(['JPM', 'JNJ', 'PG'], 2):
        df_pair = pd.concat([data[combo[0]]['5min'], data[combo[1]]['5min']], axis=1)
        df_pair.columns = list(combo)
        try_test(df_pair, f"{combo[0]} & {combo[1]}")

    print("\nüîÑ Trying log-differenced data...")
    df_trans = preprocess_for_cointegration({
        'JPM': data_dict['JPM']['5min'],
        'JNJ': data_dict['JNJ']['5min'],
        'PG': data_dict['PG']['5min']
    })
    try_test(df_trans, "Log-differenced JPM, JNJ, PG")

run_johansen_cointegration(data)

# STEP 6: Engle-Granger Cointegration (Fixed)
print("\nüìä Engle-Granger Cointegration Test (2-step method):")
pairs = [('JPM', 'JNJ'), ('JPM', 'PG'), ('JNJ', 'PG')]

for x, y in pairs:
    try:
        s1 = data[x]['5min']
        s2 = data[y]['5min']
        min_len = min(len(s1), len(s2))
        s1_aligned = s1[:min_len]
        s2_aligned = s2[:min_len]

        score, pval, _ = coint(s1_aligned, s2_aligned)
        print(f"Pair: {x} & {y} ‚Üí p-value = {pval:.4f}")
        if pval < 0.05:
            print(f"‚úÖ {x} and {y} are cointegrated (p < 0.05)")
        else:
            print(f"‚ùå No cointegration found for {x} and {y}")
    except Exception as e:
        print(f"‚ö†Ô∏è Error testing pair {x} & {y}: {str(e)}")</pre>
</body>
</html>
