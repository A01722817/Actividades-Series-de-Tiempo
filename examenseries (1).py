# -*- coding: utf-8 -*-
"""examenseries

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SwXO2_1G8hFXeZLcopxzxBC63Y8Jsgl5
"""

# ARIMA Modeling of log(PDI) from Gujarati’s Econometrics

# STEP 1: Import necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.arima.model import ARIMA
import statsmodels.api as sm

# STEP 2: Upload and read Excel file
from google.colab import files
uploaded = files.upload()  # Upload 'Macroeconomic_Data_USA.xlsx'

# STEP 3: Load data and transform
file_name = list(uploaded.keys())[0]
data = pd.read_excel(file_name)

# Create datetime index by quarters
data['Date'] = pd.date_range(start='1970-01-01', periods=len(data), freq='Q')
data.set_index('Date', inplace=True)

# Log transformation of Personal Disposable Income (PDI)
data['log_PDI'] = np.log(data['PDI'])
log_pdi = data['log_PDI']

# STEP 4: Plot original log(PDI)
plt.figure(figsize=(10,4))
plt.plot(log_pdi)
plt.title("Log of Personal Disposable Income (PDI)")
plt.xlabel("Date")
plt.ylabel("log(PDI)")
plt.grid(True)
plt.show()

# STEP 5: Augmented Dickey-Fuller Test (stationarity)
adf_result = adfuller(log_pdi)
print("ADF Statistic:", adf_result[0])
print("p-value:", adf_result[1])
print("Critical Values:", adf_result[4])

# STEP 6: Differencing to achieve stationarity
log_pdi_diff = log_pdi.diff().dropna()

# Plot differenced series
plt.figure(figsize=(10,4))
plt.plot(log_pdi_diff)
plt.title("Differenced log(PDI)")
plt.xlabel("Date")
plt.grid(True)
plt.show()

# ADF Test after differencing
adf_result_diff = adfuller(log_pdi_diff)
print("ADF Statistic (after differencing):", adf_result_diff[0])
print("p-value (after differencing):", adf_result_diff[1])
print("Critical Values:", adf_result_diff[4])

# STEP 7: ACF and PACF plots
fig, ax = plt.subplots(1,2, figsize=(14,4))
sm.graphics.tsa.plot_acf(log_pdi_diff, lags=20, ax=ax[0])
sm.graphics.tsa.plot_pacf(log_pdi_diff, lags=20, ax=ax[1])
plt.show()

# STEP 8: Fit ARIMA model (example: ARIMA(1,1,1))
model = ARIMA(log_pdi, order=(1,1,1))
model_fit = model.fit()
print(model_fit.summary())

# STEP 9: Diagnostics
model_fit.plot_diagnostics(figsize=(12,8))
plt.show()

# STEP 10: Forecasting future values
forecast_steps = 8
forecast = model_fit.get_forecast(steps=forecast_steps)
forecast_ci = forecast.conf_int()

# Plot forecast with confidence intervals
plt.figure(figsize=(10,4))
plt.plot(log_pdi, label='Observed')
plt.plot(forecast.predicted_mean, label='Forecast', color='red')
plt.fill_between(forecast_ci.index,
                 forecast_ci.iloc[:, 0],
                 forecast_ci.iloc[:, 1], color='pink', alpha=0.3)
plt.title("Forecast vs Observed log(PDI)")
plt.legend()
plt.grid(True)
plt.show()

# --- ECONOMETRÍA - GUJARATI (PREGUNTA 22.25) ---
# Treasury Bills: TB3M y TB6M (1982 - 2001)

# PASO 1: Instalar librerías necesarias
!pip install statsmodels --quiet
!pip install openpyxl --quiet

# PASO 2: Importar librerías
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.vector_ar.vecm import coint_johansen
from statsmodels.tsa.api import VAR

# PASO 3: Subir y cargar archivo
from google.colab import files
uploaded = files.upload()
file_name = list(uploaded.keys())[0]
with open(file_name, "r") as f:
    lines = f.readlines()

data_lines = [line for line in lines if line.strip() and line[:4].isdigit()]
from io import StringIO
data_str = ''.join(data_lines)
df = pd.read_csv(StringIO(data_str), delim_whitespace=True, header=None, names=["Date", "TB3M", "TB6M"])

df['Date'] = pd.to_datetime(df['Date'], format='%Y:%m')
df.set_index('Date', inplace=True)

# --- a. Gráfica comparativa ---
plt.figure(figsize=(12, 5))
plt.plot(df['TB3M'], label='TB3M - 3 Month T-Bill')
plt.plot(df['TB6M'], label='TB6M - 6 Month T-Bill')
plt.title('Tasas Treasury Bills (3M vs 6M)')
plt.xlabel('Fecha')
plt.ylabel('Tasa de interés (%)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# --- b. Prueba de raíz unitaria (ADF) ---
def test_adf(series, name):
    result = adfuller(series)
    print(f"--- ADF para {name} ---")
    print(f"ADF Statistic: {result[0]:.4f}")
    print(f"p-value: {result[1]:.4f}")
    print(f"Valores críticos: {result[4]}")
    print("Estacionaria" if result[1] < 0.05 else "NO estacionaria", "\\n")

test_adf(df['TB3M'], 'TB3M')
test_adf(df['TB6M'], 'TB6M')

# --- c. Prueba de cointegración (Johansen) ---
data_for_coint = df[['TB3M', 'TB6M']]
result = coint_johansen(data_for_coint, det_order=0, k_ar_diff=1)

print("\\n--- Cointegración (test de Johansen) ---")
print("Eigenvalue test statistic:")
print(result.lr1)
print("Valores críticos 95%:")
print(result.cvt[:, 1])
print("Conclusión:")
if result.lr1[0] > result.cvt[0, 1]:
    print("Sí hay al menos una relación de cointegración.")
else:
    print("NO hay cointegración entre las series.")

# --- d. Interpretación económica ---
print("""
Interpretación económica:
Si las series están cointegradas, significa que aunque ambas sean no estacionarias, mantienen una relación de equilibrio
a largo plazo. Es decir, la tasa de TB3M y TB6M se ajustan entre sí. Si no lo están, podrían moverse separadas y
cualquier relación entre ellas podría ser espuria.
""")

# --- e. Estimar un modelo VAR con 4 rezagos ---
adf_tb3m = adfuller(df['TB3M'])[1]
adf_tb6m = adfuller(df['TB6M'])[1]

use_diff = adf_tb3m > 0.05 and adf_tb6m > 0.05 and result.lr1[0] < result.cvt[0, 1]

if use_diff:
    print("\\nDado que las series NO son estacionarias y NO están cointegradas, usamos diferencias.")
    df_diff = df.diff().dropna()
    model_data = df_diff
else:
    print("\\nDado que las series están cointegradas o son estacionarias, usamos los niveles.")
    model_data = df

model = VAR(model_data)
results = model.fit(4)
print(results.summary())